/**
 * Spotify-Style Podcast Player
 * Handles episode loading, playback, and UI interactions
 */

class PodcastApp {
  constructor() {
    this.episodes = [];
    this.currentEpisode = null;
    this.audio = document.getElementById('audioElement');
    this.isPlaying = false;

    this.initializeElements();
    this.setupEventListeners();
    this.loadEpisodes();
  }

  initializeElements() {
    // Sections
    this.loadingState = document.getElementById('loadingState');
    this.errorState = document.getElementById('errorState');
    this.podcastLibrary = document.getElementById('podcastLibrary');

    // Featured episode
    this.featuredEpisode = document.getElementById('featuredEpisode');

    // Episode grid
    this.episodeGrid = document.getElementById('episodeGrid');
    this.sortSelect = document.getElementById('sortSelect');

    // Player bar
    this.playerBar = document.getElementById('playerBar');
    this.playerCover = document.getElementById('playerCover');
    this.playerTitle = document.getElementById('playerTitle');
    this.playerDate = document.getElementById('playerDate');

    // Player controls
    this.playPauseBtn = document.getElementById('playPauseBtn');
    this.playIcon = document.getElementById('playIcon');
    this.pauseIcon = document.getElementById('pauseIcon');
    this.skipBackBtn = document.getElementById('skipBackBtn');
    this.skipForwardBtn = document.getElementById('skipForwardBtn');

    // Progress
    this.progressSlider = document.getElementById('progressSlider');
    this.progressFillPlayer = document.getElementById('progressFillPlayer');
    this.timeCurrentPlayer = document.getElementById('timeCurrentPlayer');
    this.timeTotalPlayer = document.getElementById('timeTotalPlayer');

    // Volume & speed
    this.volumeBtn = document.getElementById('volumeBtn');
    this.volumeSlider = document.getElementById('volumeSlider');
    this.speedBtn = document.getElementById('speedBtn');

    // Speed options to cycle through
    this.speedOptions = [0.5, 0.75, 1, 1.25, 1.5, 2];
    this.currentSpeedIndex = 2; // Start at 1x
    this.previousVolume = 0.8; // Store volume before mute
  }

  setupEventListeners() {
    // Player controls
    this.playPauseBtn?.addEventListener('click', () => this.togglePlay());
    this.skipBackBtn?.addEventListener('click', () => this.skip(-15));
    this.skipForwardBtn?.addEventListener('click', () => this.skip(15));

    // Progress bar
    this.progressSlider?.addEventListener('input', (e) => this.seek(e.target.value));

    // Volume button (mute/unmute)
    this.volumeBtn?.addEventListener('click', () => this.toggleMute());

    // Volume slider
    this.volumeSlider?.addEventListener('input', (e) => this.setVolume(e.target.value));

    // Speed button (cycle through speeds)
    this.speedBtn?.addEventListener('click', () => this.cycleSpeed());

    // Audio events
    this.audio.addEventListener('timeupdate', () => this.updateProgress());
    this.audio.addEventListener('loadedmetadata', () => this.onMetadataLoaded());
    this.audio.addEventListener('ended', () => this.onEnded());
    this.audio.addEventListener('play', () => this.onPlay());
    this.audio.addEventListener('pause', () => this.onPause());

    // Sort
    this.sortSelect?.addEventListener('change', () => this.sortEpisodes());

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => this.handleKeyboard(e));
  }

  async loadEpisodes() {
    try {
      this.showSection('loading');

      // Fetch episodes from API
      const apiUrl = getApiUrl('/podcasts');
      console.log('Fetching episodes from:', apiUrl);

      const response = await fetch(apiUrl);

      if (!response.ok) {
        throw new Error(`Failed to fetch episodes: ${response.status}`);
      }

      const data = await response.json();
      this.episodes = data.episodes || [];

      console.log(`Loaded ${this.episodes.length} episodes`);

      if (this.episodes.length === 0) {
        this.showError('No episodes found. Episodes will appear here once generated by the daily cron job.');
        return;
      }

      // Display episodes
      this.renderFeaturedEpisode();
      this.renderEpisodeGrid();
      this.showSection('library');

    } catch (error) {
      console.error('Error loading episodes:', error);
      this.showError(error.message);
    }
  }

  renderFeaturedEpisode() {
    if (this.episodes.length === 0) return;

    const latest = this.episodes[0];
    const date = new Date(latest.publication_date);

    this.featuredEpisode.innerHTML = `
      <div class="featured-cover" data-episode-id="${latest.id}">
        üéôÔ∏è
      </div>
      <div class="featured-details">
        <div class="featured-label">Latest Episode</div>
        <h1 class="featured-title">${this.escapeHtml(latest.title)}</h1>
        <div class="featured-meta">
          ${date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })} ‚Ä¢
          ${this.formatDuration(latest.duration_seconds)}
        </div>
        <p class="featured-description">
          ${this.escapeHtml(latest.description || 'Your daily AI-generated neutral news podcast')}
        </p>
        <button class="featured-play-btn" onclick="podcastApp.playEpisode('${latest.id}')">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
          </svg>
          Play Episode
        </button>
      </div>
    `;
  }

  renderEpisodeGrid() {
    if (this.episodes.length === 0) return;

    this.episodeGrid.innerHTML = this.episodes.map(episode => {
      const date = new Date(episode.publication_date);
      return `
        <div class="episode-card" onclick="podcastApp.playEpisode('${episode.id}')">
          <div class="episode-card-cover-wrapper">
            <div class="episode-card-cover">üéôÔ∏è</div>
            <div class="play-overlay">
              <button class="play-overlay-btn">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M8 5v14l11-7z"/>
                </svg>
              </button>
            </div>
          </div>
          <h3 class="episode-card-title">${this.escapeHtml(episode.title)}</h3>
          <div class="episode-card-meta">
            <span>${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</span>
            <span>${this.formatDuration(episode.duration_seconds)}</span>
          </div>
        </div>
      `;
    }).join('');
  }

  playEpisode(episodeId) {
    const episode = this.episodes.find(e => e.id === episodeId);
    if (!episode) return;

    this.currentEpisode = episode;

    // Update player bar
    this.playerTitle.textContent = episode.title;
    const date = new Date(episode.publication_date);
    this.playerDate.textContent = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

    // Load and play audio
    this.audio.src = episode.audio_url;
    this.audio.load();

    // Set initial playback rate
    this.audio.playbackRate = this.speedOptions[this.currentSpeedIndex];

    this.audio.play();

    // Show player bar
    this.playerBar.classList.remove('hidden');

    console.log('Playing episode:', episode.title);
  }

  togglePlay() {
    if (!this.audio.src) return;

    if (this.isPlaying) {
      this.audio.pause();
    } else {
      this.audio.play();
    }
  }

  onPlay() {
    this.isPlaying = true;
    this.playIcon.classList.add('hidden');
    this.pauseIcon.classList.remove('hidden');
  }

  onPause() {
    this.isPlaying = false;
    this.playIcon.classList.remove('hidden');
    this.pauseIcon.classList.add('hidden');
  }

  onEnded() {
    this.isPlaying = false;
    this.playIcon.classList.remove('hidden');
    this.pauseIcon.classList.add('hidden');
    this.audio.currentTime = 0;
  }

  skip(seconds) {
    if (!this.audio.src) return;
    this.audio.currentTime = Math.max(0, Math.min(this.audio.duration, this.audio.currentTime + seconds));
  }

  seek(value) {
    if (!this.audio.duration) return;
    const time = (value / 100) * this.audio.duration;
    this.audio.currentTime = time;
  }

  setVolume(value) {
    this.audio.volume = value / 100;
    if (value > 0) {
      this.previousVolume = value / 100;
    }
  }

  toggleMute() {
    if (this.audio.volume > 0) {
      // Mute
      this.previousVolume = this.audio.volume;
      this.audio.volume = 0;
      this.volumeSlider.value = 0;
    } else {
      // Unmute
      this.audio.volume = this.previousVolume;
      this.volumeSlider.value = this.previousVolume * 100;
    }
  }

  cycleSpeed() {
    // Cycle to next speed
    this.currentSpeedIndex = (this.currentSpeedIndex + 1) % this.speedOptions.length;
    const newSpeed = this.speedOptions[this.currentSpeedIndex];
    this.audio.playbackRate = newSpeed;
    if (this.speedBtn) {
      this.speedBtn.textContent = `${newSpeed}x`;
    }
    console.log(`Playback speed changed to ${newSpeed}x`);
  }

  setSpeed(rate) {
    this.audio.playbackRate = parseFloat(rate);
  }

  updateProgress() {
    if (!this.audio.duration) return;

    const progress = (this.audio.currentTime / this.audio.duration) * 100;
    this.progressSlider.value = progress;
    this.progressFillPlayer.style.width = `${progress}%`;

    this.timeCurrentPlayer.textContent = this.formatTime(this.audio.currentTime);
  }

  onMetadataLoaded() {
    this.timeTotalPlayer.textContent = this.formatTime(this.audio.duration);
  }

  sortEpisodes() {
    const sortBy = this.sortSelect.value;

    if (sortBy === 'newest') {
      this.episodes.sort((a, b) => new Date(b.publication_date) - new Date(a.publication_date));
    } else if (sortBy === 'oldest') {
      this.episodes.sort((a, b) => new Date(a.publication_date) - new Date(b.publication_date));
    }

    this.renderEpisodeGrid();
  }

  handleKeyboard(e) {
    // Only handle if player is visible and not in an input
    if (this.playerBar.classList.contains('hidden')) return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

    switch(e.code) {
      case 'Space':
        e.preventDefault();
        this.togglePlay();
        break;
      case 'ArrowLeft':
        e.preventDefault();
        this.skip(-15);
        break;
      case 'ArrowRight':
        e.preventDefault();
        this.skip(15);
        break;
    }
  }

  showSection(section) {
    this.loadingState.classList.add('hidden');
    this.errorState.classList.add('hidden');
    this.podcastLibrary.classList.add('hidden');

    if (section === 'loading') {
      this.loadingState.classList.remove('hidden');
    } else if (section === 'error') {
      this.errorState.classList.remove('hidden');
    } else if (section === 'library') {
      this.podcastLibrary.classList.remove('hidden');
    }
  }

  showError(message) {
    document.getElementById('errorMessage').textContent = message;
    this.showSection('error');
  }

  formatTime(seconds) {
    if (!seconds || isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  formatDuration(seconds) {
    if (!seconds) return '0 min';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    if (secs === 0) return `${mins} min`;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Initialize app when DOM is ready
let podcastApp;
document.addEventListener('DOMContentLoaded', () => {
  console.log('Initializing Spotify-style podcast app...');
  podcastApp = new PodcastApp();
  window.podcastApp = podcastApp; // Make globally accessible
});
